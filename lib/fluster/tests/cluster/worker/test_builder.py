# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for VenvCache and ImageCache."""

import subprocess

import pytest
from fluster.cluster.worker.builder import ImageCache, VenvCache


@pytest.fixture
def test_bundle(tmp_path):
    """Create a test bundle with pyproject.toml and uv.lock."""
    bundle_dir = tmp_path / "test_bundle"
    bundle_dir.mkdir()

    # Create minimal pyproject.toml
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock file
    # This is a minimal lock file - in real usage it would be generated by uv
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-package"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


@pytest.fixture
def test_bundle_with_deps(tmp_path):
    """Create a test bundle with actual dependencies for real uv testing."""
    bundle_dir = tmp_path / "test_bundle_deps"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_package"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text("# Test package\n")

    # Create pyproject.toml with a simple dependency
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "httpx>=0.28.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_package"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Run uv lock to generate real lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    return bundle_dir


def test_compute_deps_hash(test_bundle):
    """Test that deps hash is computed from pyproject.toml and uv.lock."""
    cache = VenvCache()

    hash1 = cache.compute_deps_hash(test_bundle)

    # Should be consistent
    hash2 = cache.compute_deps_hash(test_bundle)
    assert hash1 == hash2

    # Modify pyproject.toml
    (test_bundle / "pyproject.toml").write_text("[project]\nname = 'changed'\n")
    hash3 = cache.compute_deps_hash(test_bundle)

    # Hash should change
    assert hash3 != hash1


# ImageCache Tests


@pytest.fixture
def docker_bundle(tmp_path):
    """Create a minimal test bundle for Docker builds."""
    bundle_dir = tmp_path / "docker_bundle"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')
    (src_dir / "main.py").write_text(
        'def main():\n    print("Hello from Docker!")\n\nif __name__ == "__main__":\n    main()\n'
    )

    # Create pyproject.toml
    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-app"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


def check_docker_available():
    """Check if Docker is available and running."""
    try:
        result = subprocess.run(
            ["docker", "info"],
            check=True,
            capture_output=True,
            timeout=5,
        )
        return result.returncode == 0
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        return False


@pytest.mark.slow
def test_image_cache_initialization(tmp_path):
    """Test ImageCache initialization creates cache directory."""
    cache_dir = tmp_path / "cache"
    ImageCache(cache_dir, registry="localhost:5000", max_images=10)

    assert (cache_dir / "images").exists()


@pytest.mark.slow
def test_image_caching(tmp_path, docker_bundle):
    """Test that subsequent builds with same deps_hash use cached image."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "cache-test-456"
    deps_hash = "cachedep1234567890"
    base_image = "python:3.11-slim"

    # First build - not from cache
    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    assert result1.from_cache is False
    assert result1.build_time_ms > 0

    # Second build - should be from cache
    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    assert result2.from_cache is True
    assert result2.build_time_ms == 0
    assert result2.image_tag == result1.image_tag

    # Cleanup
    subprocess.run(["docker", "rmi", result1.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_deps_hash_change_triggers_rebuild(tmp_path, docker_bundle):
    """Test that changing deps_hash triggers a rebuild."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "rebuild-test-789"
    base_image = "python:3.11-slim"

    # Build with first deps_hash
    deps_hash1 = "oldhash1234567890"
    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash1,
    )

    assert result1.from_cache is False
    expected_tag1 = f"localhost:5000/fluster-job-{job_id}:{deps_hash1[:8]}"
    assert result1.image_tag == expected_tag1

    # Build with different deps_hash - should rebuild
    deps_hash2 = "newhash0987654321"
    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash2,
    )

    assert result2.from_cache is False
    expected_tag2 = f"localhost:5000/fluster-job-{job_id}:{deps_hash2[:8]}"
    assert result2.image_tag == expected_tag2
    assert result2.image_tag != result1.image_tag

    # Both images should exist
    exists1 = builder._docker.exists(expected_tag1)
    exists2 = builder._docker.exists(expected_tag2)
    assert exists1 is True
    assert exists2 is True

    # Cleanup
    subprocess.run(["docker", "rmi", expected_tag1], stdout=subprocess.DEVNULL, check=False)
    subprocess.run(["docker", "rmi", expected_tag2], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_buildkit_cache_mounts(tmp_path, docker_bundle):
    """Test that BuildKit cache mounts are used for UV cache."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Verify DOCKER_BUILDKIT is set in environment during build
    job_id = "buildkit-test-abc"
    deps_hash = "buildkit1234567890"
    base_image = "python:3.11-slim"

    # Build image - BuildKit should be enabled
    result = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    # Verify image was built (BuildKit enabled by default in _docker_build)
    assert result.from_cache is False
    exists = builder._docker.exists(result.image_tag)
    assert exists is True

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_image_build_with_extras(tmp_path):
    """Test building image with extras."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    # Create bundle with extras
    bundle_dir = tmp_path / "extras_bundle"
    bundle_dir.mkdir()

    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')

    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[project.optional-dependencies]
dev = []
test = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Generate proper lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Build with extras
    result = builder.build(
        bundle_path=bundle_dir,
        base_image="python:3.11-slim",
        extras=["dev", "test"],
        job_id="extras-test",
        deps_hash="extrahash123",
    )

    assert result.from_cache is False

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_lru_eviction_of_images(tmp_path, docker_bundle):
    """Test LRU eviction removes old images when over limit."""
    import uuid

    if not check_docker_available():
        pytest.skip("Docker not available")

    # Use a unique registry prefix to isolate this test's images from other runs.
    # The eviction pattern matches {registry}/fluster-job-*, so unique registry = isolation.
    test_id = uuid.uuid4().hex[:8]
    test_registry = f"lru-test-{test_id}"

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry=test_registry, max_images=2)

    base_image = "python:3.11-slim"
    images_built = []

    # Build 3 images to trigger eviction.
    # Eviction sorts by (created_at, tag). When timestamps are identical
    # (common with shared layers), tag is the tiebreaker: job-0 < job-1 < job-2
    for i in range(3):
        result = builder.build(
            bundle_path=docker_bundle,
            base_image=base_image,
            extras=[],
            job_id=f"job-{i}",
            deps_hash=f"deps{i:016d}",
        )
        images_built.append(result.image_tag)

    # After building 3 images with max_images=2, oldest should be evicted
    # Note: _evict_old_images is called after each build, but only when count > max_images

    # The oldest image (image 0) should have been evicted
    exists_0 = builder._docker.exists(images_built[0])
    assert exists_0 is False, "Oldest image should have been evicted"

    # The newest images should exist
    exists_1 = builder._docker.exists(images_built[1])
    exists_2 = builder._docker.exists(images_built[2])
    assert exists_1 is True, "Second image should exist"
    assert exists_2 is True, "Newest image should exist"

    # Cleanup remaining images
    for tag in images_built:
        try:
            subprocess.run(["docker", "rmi", tag], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except Exception:
            pass  # Image may already be evicted
