# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for VenvCache and ImageCache."""

import subprocess

import pytest

from fluster.cluster.worker.builder import ImageCache, VenvCache


@pytest.fixture
def temp_cache_dir(tmp_path):
    """Create a temporary cache directory."""
    cache_dir = tmp_path / "cache"
    uv_cache_dir = tmp_path / "uv_cache"
    cache_dir.mkdir()
    uv_cache_dir.mkdir()
    return cache_dir, uv_cache_dir


@pytest.fixture
def uv_cache_dir(tmp_path):
    """Create a temporary UV cache directory."""
    uv_cache_dir = tmp_path / "uv_cache"
    uv_cache_dir.mkdir()
    return uv_cache_dir


@pytest.fixture
def test_bundle(tmp_path):
    """Create a test bundle with pyproject.toml and uv.lock."""
    bundle_dir = tmp_path / "test_bundle"
    bundle_dir.mkdir()

    # Create minimal pyproject.toml
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock file
    # This is a minimal lock file - in real usage it would be generated by uv
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-package"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


@pytest.fixture
def test_bundle_with_deps(tmp_path):
    """Create a test bundle with actual dependencies for real uv testing."""
    bundle_dir = tmp_path / "test_bundle_deps"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_package"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text("# Test package\n")

    # Create pyproject.toml with a simple dependency
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "httpx>=0.28.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_package"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Run uv lock to generate real lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    return bundle_dir


def test_compute_deps_hash(uv_cache_dir, test_bundle):
    """Test that deps hash is computed from pyproject.toml and uv.lock."""
    cache = VenvCache(uv_cache_dir)

    hash1 = cache.compute_deps_hash(test_bundle)

    # Should be consistent
    hash2 = cache.compute_deps_hash(test_bundle)
    assert hash1 == hash2

    # Modify pyproject.toml
    (test_bundle / "pyproject.toml").write_text("[project]\nname = 'changed'\n")
    hash3 = cache.compute_deps_hash(test_bundle)

    # Hash should change
    assert hash3 != hash1


def test_ensure_permissions(uv_cache_dir):
    """Test ensure_permissions sets correct ownership."""
    cache = VenvCache(uv_cache_dir)

    # Create some files in uv cache
    test_file = uv_cache_dir / "test.txt"
    test_file.write_text("test")

    subdir = uv_cache_dir / "subdir"
    subdir.mkdir()
    (subdir / "file.txt").write_text("test")

    # Try to set permissions (may fail if not running as root)
    # This test verifies the method runs without error
    try:
        cache.ensure_permissions(uid=1000, gid=1000)
    except PermissionError:
        # Expected on systems where we can't change ownership
        pass


# ImageCache Tests


@pytest.fixture
def docker_bundle(tmp_path):
    """Create a minimal test bundle for Docker builds."""
    bundle_dir = tmp_path / "docker_bundle"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')
    (src_dir / "main.py").write_text(
        'def main():\n    print("Hello from Docker!")\n\nif __name__ == "__main__":\n    main()\n'
    )

    # Create pyproject.toml
    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-app"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


def check_docker_available():
    """Check if Docker is available and running."""
    try:
        result = subprocess.run(
            ["docker", "info"],
            check=True,
            capture_output=True,
            timeout=5,
        )
        return result.returncode == 0
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        return False


@pytest.mark.slow
def test_image_cache_initialization(tmp_path):
    """Test ImageCache initialization creates cache directory."""
    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000", max_images=10)

    assert builder._cache_dir == cache_dir / "images"
    assert builder._registry == "localhost:5000"
    assert builder._max_images == 10
    assert builder._cache_dir.exists()


@pytest.mark.slow
def test_image_exists_returns_false_for_missing_image(tmp_path):
    """Test _image_exists returns False for non-existent image."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    exists = builder._docker.exists("nonexistent:tag")
    assert exists is False


@pytest.mark.slow
def test_content_addressed_image_tags(tmp_path, docker_bundle):
    """Test that ImageCache generates content-addressed image tags."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "test-job-123"
    deps_hash = "abcdef1234567890"
    base_image = "python:3.11-slim"

    # Build image
    result = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    # Verify content-addressed tag format
    expected_tag = f"localhost:5000/fluster-job-{job_id}:{deps_hash[:8]}"
    assert result.image_tag == expected_tag
    assert result.deps_hash == deps_hash
    assert result.from_cache is False
    assert result.build_time_ms > 0

    # Verify image exists
    exists = builder._docker.exists(expected_tag)
    assert exists is True

    # Cleanup
    subprocess.run(["docker", "rmi", expected_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_image_caching(tmp_path, docker_bundle):
    """Test that subsequent builds with same deps_hash use cached image."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "cache-test-456"
    deps_hash = "cachedep1234567890"
    base_image = "python:3.11-slim"

    # First build - not from cache
    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    assert result1.from_cache is False
    assert result1.build_time_ms > 0

    # Second build - should be from cache
    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    assert result2.from_cache is True
    assert result2.build_time_ms == 0
    assert result2.image_tag == result1.image_tag

    # Cleanup
    subprocess.run(["docker", "rmi", result1.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_deps_hash_change_triggers_rebuild(tmp_path, docker_bundle):
    """Test that changing deps_hash triggers a rebuild."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "rebuild-test-789"
    base_image = "python:3.11-slim"

    # Build with first deps_hash
    deps_hash1 = "oldhash1234567890"
    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash1,
    )

    assert result1.from_cache is False
    expected_tag1 = f"localhost:5000/fluster-job-{job_id}:{deps_hash1[:8]}"
    assert result1.image_tag == expected_tag1

    # Build with different deps_hash - should rebuild
    deps_hash2 = "newhash0987654321"
    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash2,
    )

    assert result2.from_cache is False
    expected_tag2 = f"localhost:5000/fluster-job-{job_id}:{deps_hash2[:8]}"
    assert result2.image_tag == expected_tag2
    assert result2.image_tag != result1.image_tag

    # Both images should exist
    exists1 = builder._docker.exists(expected_tag1)
    exists2 = builder._docker.exists(expected_tag2)
    assert exists1 is True
    assert exists2 is True

    # Cleanup
    subprocess.run(["docker", "rmi", expected_tag1], stdout=subprocess.DEVNULL, check=False)
    subprocess.run(["docker", "rmi", expected_tag2], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_buildkit_cache_mounts(tmp_path, docker_bundle):
    """Test that BuildKit cache mounts are used for UV cache."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Verify DOCKER_BUILDKIT is set in environment during build
    job_id = "buildkit-test-abc"
    deps_hash = "buildkit1234567890"
    base_image = "python:3.11-slim"

    # Build image - BuildKit should be enabled
    result = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
        deps_hash=deps_hash,
    )

    # Verify image was built (BuildKit enabled by default in _docker_build)
    assert result.from_cache is False
    exists = builder._docker.exists(result.image_tag)
    assert exists is True

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_image_build_with_extras(tmp_path):
    """Test building image with extras."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    # Create bundle with extras
    bundle_dir = tmp_path / "extras_bundle"
    bundle_dir.mkdir()

    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')

    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[project.optional-dependencies]
dev = []
test = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Generate proper lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Build with extras
    result = builder.build(
        bundle_path=bundle_dir,
        base_image="python:3.11-slim",
        extras=["dev", "test"],
        job_id="extras-test",
        deps_hash="extrahash123",
    )

    assert result.from_cache is False

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_lru_eviction_of_images(tmp_path, docker_bundle):
    """Test LRU eviction removes old images when over limit."""
    import time

    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000", max_images=2)

    base_image = "python:3.11-slim"
    images_built = []

    # Build 3 images to trigger eviction
    for i in range(3):
        result = builder.build(
            bundle_path=docker_bundle,
            base_image=base_image,
            extras=[],
            job_id=f"eviction-test-{i}",
            deps_hash=f"evict{i:016d}",
        )
        images_built.append(result.image_tag)

        # Small delay to ensure different creation times
        time.sleep(0.1)

    # After building 3 images with max_images=2, oldest should be evicted
    # Note: _evict_old_images is called after each build, but only when count > max_images

    # At least the newest image should exist
    exists_2 = builder._docker.exists(images_built[2])
    assert exists_2 is True

    # Cleanup remaining images
    for tag in images_built:
        try:
            subprocess.run(["docker", "rmi", tag], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except Exception:
            pass  # Image may already be evicted


def test_dockerfile_template_formatting():
    """Test that Dockerfile template is formatted correctly."""
    from fluster.cluster.worker.builder import DOCKERFILE_TEMPLATE

    # Test with no extras
    dockerfile = DOCKERFILE_TEMPLATE.format(base_image="python:3.11-slim", extras_flags="")
    assert "FROM python:3.11-slim" in dockerfile
    assert "ghcr.io/astral-sh/uv:latest" in dockerfile
    assert "UV_CACHE_DIR=/opt/uv-cache" in dockerfile
    assert "--mount=type=cache,target=/opt/uv-cache" in dockerfile

    # Test with extras
    dockerfile = DOCKERFILE_TEMPLATE.format(base_image="python:3.12", extras_flags="--extra dev --extra test")
    assert "FROM python:3.12" in dockerfile
    assert "--extra dev --extra test" in dockerfile
