# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Generated by https://github.com/connectrpc/connect-python.  DO NOT EDIT!
# source: actor.proto

from collections.abc import AsyncGenerator, Iterable, Mapping
from typing import Protocol

from connectrpc.client import ConnectClient, ConnectClientSync
from connectrpc.code import Code
from connectrpc.errors import ConnectError
from connectrpc.interceptor import Interceptor, InterceptorSync
from connectrpc.method import IdempotencyLevel, MethodInfo
from connectrpc.request import Headers, RequestContext
from connectrpc.server import ConnectASGIApplication, ConnectWSGIApplication, Endpoint, EndpointSync
from . import actor_pb2 as actor__pb2


class ActorService(Protocol):
    async def call(self, request: actor__pb2.ActorCall, ctx: RequestContext) -> actor__pb2.ActorResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    async def health_check(self, request: actor__pb2.Empty, ctx: RequestContext) -> actor__pb2.HealthResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class ActorServiceASGIApplication(ConnectASGIApplication[ActorService]):
    def __init__(
        self,
        service: ActorService | AsyncGenerator[ActorService],
        *,
        interceptors: Iterable[Interceptor] = (),
        read_max_bytes: int | None = None,
    ) -> None:
        super().__init__(
            service=service,
            endpoints=lambda svc: {
                "/fluster.actor.ActorService/Call": Endpoint.unary(
                    method=MethodInfo(
                        name="Call",
                        service_name="fluster.actor.ActorService",
                        input=actor__pb2.ActorCall,
                        output=actor__pb2.ActorResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.call,
                ),
                "/fluster.actor.ActorService/HealthCheck": Endpoint.unary(
                    method=MethodInfo(
                        name="HealthCheck",
                        service_name="fluster.actor.ActorService",
                        input=actor__pb2.Empty,
                        output=actor__pb2.HealthResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=svc.health_check,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/fluster.actor.ActorService"


class ActorServiceClient(ConnectClient):
    async def call(
        self,
        request: actor__pb2.ActorCall,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> actor__pb2.ActorResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Call",
                service_name="fluster.actor.ActorService",
                input=actor__pb2.ActorCall,
                output=actor__pb2.ActorResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    async def health_check(
        self,
        request: actor__pb2.Empty,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> actor__pb2.HealthResponse:
        return await self.execute_unary(
            request=request,
            method=MethodInfo(
                name="HealthCheck",
                service_name="fluster.actor.ActorService",
                input=actor__pb2.Empty,
                output=actor__pb2.HealthResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )


class ActorServiceSync(Protocol):
    def call(self, request: actor__pb2.ActorCall, ctx: RequestContext) -> actor__pb2.ActorResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")

    def health_check(self, request: actor__pb2.Empty, ctx: RequestContext) -> actor__pb2.HealthResponse:
        raise ConnectError(Code.UNIMPLEMENTED, "Not implemented")


class ActorServiceWSGIApplication(ConnectWSGIApplication):
    def __init__(
        self, service: ActorServiceSync, interceptors: Iterable[InterceptorSync] = (), read_max_bytes: int | None = None
    ) -> None:
        super().__init__(
            endpoints={
                "/fluster.actor.ActorService/Call": EndpointSync.unary(
                    method=MethodInfo(
                        name="Call",
                        service_name="fluster.actor.ActorService",
                        input=actor__pb2.ActorCall,
                        output=actor__pb2.ActorResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.call,
                ),
                "/fluster.actor.ActorService/HealthCheck": EndpointSync.unary(
                    method=MethodInfo(
                        name="HealthCheck",
                        service_name="fluster.actor.ActorService",
                        input=actor__pb2.Empty,
                        output=actor__pb2.HealthResponse,
                        idempotency_level=IdempotencyLevel.UNKNOWN,
                    ),
                    function=service.health_check,
                ),
            },
            interceptors=interceptors,
            read_max_bytes=read_max_bytes,
        )

    @property
    def path(self) -> str:
        """Returns the URL path to mount the application to when serving multiple applications."""
        return "/fluster.actor.ActorService"


class ActorServiceClientSync(ConnectClientSync):
    def call(
        self,
        request: actor__pb2.ActorCall,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> actor__pb2.ActorResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="Call",
                service_name="fluster.actor.ActorService",
                input=actor__pb2.ActorCall,
                output=actor__pb2.ActorResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )

    def health_check(
        self,
        request: actor__pb2.Empty,
        *,
        headers: Headers | Mapping[str, str] | None = None,
        timeout_ms: int | None = None,
    ) -> actor__pb2.HealthResponse:
        return self.execute_unary(
            request=request,
            method=MethodInfo(
                name="HealthCheck",
                service_name="fluster.actor.ActorService",
                input=actor__pb2.Empty,
                output=actor__pb2.HealthResponse,
                idempotency_level=IdempotencyLevel.UNKNOWN,
            ),
            headers=headers,
            timeout_ms=timeout_ms,
        )
