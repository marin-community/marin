# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import abc
import re
from dataclasses import dataclass
from typing import ClassVar

from marin.generation.dataset import convert_labeled_document_to_score
from zephyr import Dataset, execute, load_jsonl


@dataclass
class DatasetOutputProcessorConfig:
    input_path: str
    output_path: str
    processor_type: str


class DatasetOutputProcessor:
    """Base class for converting labeled documents into a dataset of parsed scores.

    This processor will take in a path to a directory of labeled documents with a "text" and "generated_text" field
    where "text" is the original text and "generated_text" is the text generated by the model. The processor
    will then convert the labeled documents into a dataset of parsed scores by implementing
    the `extract_score` method.

    Inputs:
        input_path: The path to the input file.
        output_path: The path to the output file.
        score_values: The list of score values (the possible values that the score can take on).
    """

    def __init__(self, input_path: str, output_path: str, score_values: list[int]):
        self.input_path = input_path
        self.output_path = output_path
        self.score_values = score_values
        self.score_distribution = {v: 0 for v in score_values}

    @abc.abstractmethod
    def extract_score(text: str) -> int:
        raise NotImplementedError("Subclasses must implement this method")

    def convert_dataset(self):
        pipeline = (
            Dataset.from_files(f"{self.input_path}/**/*.jsonl.gz")
            .flat_map(load_jsonl)
            .map(lambda example: convert_labeled_document_to_score(example, extract_score_fn=self.extract_score))
            .filter(lambda record: record is not None)
            .write_jsonl(f"{self.output_path}/data-{{shard:05d}}-of-{{total:05d}}.jsonl.gz")
        )

        execute(pipeline)
        return self.score_distribution


class MeduDatasetOutputProcessor(DatasetOutputProcessor):
    SCORE_OPTIONS_DICT: ClassVar[dict[str, int]] = {
        "Great": 5,
        "Good": 4,
        "Okay": 3,
        "Poor": 2,
        "Useless": 1,
    }

    def __init__(self, input_path: str, output_path: str):
        super().__init__(input_path, output_path, list(MeduDatasetOutputProcessor.SCORE_OPTIONS_DICT.values()))

    @staticmethod
    def extract_score(text: str) -> int:

        # Match "Final Score: " followed by one of the score options
        match = re.search(r"Final Score:\s*(Great|Good|Okay|Poor|Useless)", text)
        if match:
            score_text = match.group(1)
            return MeduDatasetOutputProcessor.SCORE_OPTIONS_DICT[score_text]

        return -1


class FinalScoreZeroToFiveDatasetOutputProcessor(DatasetOutputProcessor):
    SCORE_OPTIONS_DICT: ClassVar[dict[str, int]] = {str(i): i for i in range(6)}

    def __init__(self, input_path: str, output_path: str):
        super().__init__(
            input_path, output_path, list(FinalScoreZeroToFiveDatasetOutputProcessor.SCORE_OPTIONS_DICT.values())
        )

    @staticmethod
    def extract_score(text: str) -> int:

        # Match "Final score: " followed by a number from 0 to 5
        match = re.search(r"Final score:\s*([0-5])", text, re.IGNORECASE)
        if match:
            score_text = match.group(1)
            return FinalScoreZeroToFiveDatasetOutputProcessor.SCORE_OPTIONS_DICT[score_text]

        return -1


class AutoDatasetOutputProcessor(DatasetOutputProcessor):
    _PROCESSOR_TYPE_TO_CLS: ClassVar[dict] = {
        "medu": MeduDatasetOutputProcessor,
        "finalscore0-5": FinalScoreZeroToFiveDatasetOutputProcessor,
    }

    @classmethod
    def from_processor_type(cls, input_path, output_path, processor_type):
        processor_cls = cls._PROCESSOR_TYPE_TO_CLS[processor_type]
        return processor_cls(input_path, output_path)
