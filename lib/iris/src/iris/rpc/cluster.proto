// Copyright 2025 The Marin Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

edition = "2023";

package iris.cluster;

import "vm.proto";

// ============================================================================
// SHARED TYPES
// ============================================================================

message Empty {}

enum JobState {
  JOB_STATE_UNSPECIFIED = 0;
  JOB_STATE_PENDING = 1;
  JOB_STATE_BUILDING = 2;
  JOB_STATE_RUNNING = 3;
  JOB_STATE_SUCCEEDED = 4;
  JOB_STATE_FAILED = 5;
  JOB_STATE_KILLED = 6;
  JOB_STATE_WORKER_FAILED = 7;
  JOB_STATE_UNSCHEDULABLE = 8;  // Couldn't be scheduled within timeout
}

// Task state mirrors job state - a task is a single unit of execution within a job
enum TaskState {
  TASK_STATE_UNSPECIFIED = 0;
  TASK_STATE_PENDING = 1;
  TASK_STATE_BUILDING = 2;
  TASK_STATE_RUNNING = 3;
  TASK_STATE_SUCCEEDED = 4;
  TASK_STATE_FAILED = 5;
  TASK_STATE_KILLED = 6;
  TASK_STATE_WORKER_FAILED = 7;
  TASK_STATE_UNSCHEDULABLE = 8;
}

// Status of a single task within a job
message TaskStatus {
  string task_id = 1;                 // "{job_id}/task-{index}"
  string job_id = 2;
  int32 task_index = 3;               // 0-indexed task number
  TaskState state = 4;

  string worker_id = 5;
  string worker_address = 6;

  int32 exit_code = 7;
  string error = 8;

  int64 started_at_ms = 9;
  int64 finished_at_ms = 10;

  map<string, int32> ports = 11;      // Per-task port allocations
  ResourceUsage resource_usage = 12;
  BuildMetrics build_metrics = 13;

  int32 current_attempt_id = 14;
  repeated TaskAttempt attempts = 15;

  // Scheduling diagnostics for pending tasks (dashboard display)
  string pending_reason = 16;         // Why task can't be scheduled (empty if schedulable)
  bool can_be_scheduled = 17;         // Whether task is currently schedulable
}

// Record of a single task execution attempt
message TaskAttempt {
  int32 attempt_id = 1;
  string worker_id = 2;
  TaskState state = 3;
  int32 exit_code = 4;
  string error = 5;
  int64 started_at_ms = 6;
  int64 finished_at_ms = 7;
  bool is_worker_failure = 8;
}

message ResourceUsage {
  int64 memory_mb = 1;
  int64 disk_mb = 2;
  int32 cpu_millicores = 3;
  int64 memory_peak_mb = 4;
  int32 cpu_percent = 5;
  int32 process_count = 6;
}

message BuildMetrics {
  int64 build_started_ms = 1;
  int64 build_finished_ms = 2;
  bool from_cache = 3;
  string image_tag = 4;
}

message JobStatus {
  string job_id = 1;
  JobState state = 2;
  int32 exit_code = 3;
  string error = 4;
  int64 started_at_ms = 5;
  int64 finished_at_ms = 6;

  // Port allocations
  map<string, int32> ports = 7;

  ResourceUsage resource_usage = 8;

  // Status message for current phase (e.g., "downloading bundle", "populating uv cache")
  string status_message = 9;

  BuildMetrics build_metrics = 10;

  bytes serialized_result = 13;  // cloudpickle serialized return value (if requested)

  // Parent job ID for hierarchical job tracking (empty string if root job)
  string parent_job_id = 14;

  int32 failure_count = 17;                // Total task failures (aggregated)
  int32 preemption_count = 18;             // Total task preemptions (aggregated)

  repeated TaskStatus tasks = 24;          // Per-task status (always included)

  // Job metadata from request (for dashboard display)
  string name = 25;                        // Job name from request
  int64 submitted_at_ms = 26;              // Submission timestamp

  // Resource specification from job request (for dashboard display)
  ResourceSpecProto resources = 27;

  // Aggregated task state counts: {"running": 2, "pending": 5, "succeeded": 10}
  map<string, int32> task_state_counts = 28;

  // Convenience counts (could derive from task_state_counts)
  int32 task_count = 29;
  int32 completed_count = 30;
}

// JobAttempt message removed: Jobs don't have attempts - tasks do.
// Job state is derived from task states, and retry semantics are per-task.

// ============================================================================
// RESOURCE SPECIFICATION
// ============================================================================

// Device configuration - used in ResourceSpecProto
message DeviceConfig {
  oneof device {
    CpuDevice cpu = 1;
    GpuDevice gpu = 2;
    TpuDevice tpu = 3;
  }
}

message CpuDevice {
  string variant = 1;  // Always "cpu"
}

message GpuDevice {
  string variant = 1;  // e.g., "A100", "H100", "auto"
  int32 count = 2;     // Number of GPUs
}

message TpuDevice {
  string variant = 1;       // e.g., "v5litepod-16", "v4-8"
  string topology = 2;      // topology spec (e.g., "2x2x1")
  int32 count = 3;          // Number of TPU chips on this worker
}

// Unified resource specification for jobs
// Used by both controller (for scheduling) and worker (for enforcement)
// All resource quantities are in machine-readable units (bytes, cores).
// Clients should create a ResourceSpec dataclass and call .to_proto().
message ResourceSpecProto {
  // Compute resources
  int32 cpu = 1;              // Number of CPU cores
  int64 memory_bytes = 4;     // RAM in bytes
  int64 disk_bytes = 9;       // Disk space in bytes

  // Device configuration
  DeviceConfig device = 5;

  // Multi-instance configuration
  int32 replicas = 6;         // Number of replicas/slices

  // Scheduling preferences
  bool preemptible = 7;
  repeated string regions = 8; // Preferred cloud regions
}

// ============================================================================
// ENVIRONMENT CONFIGURATION
// ============================================================================

// Job environment configuration
// Exactly one of workspace or docker_image must be set (enforced in client)
message EnvironmentConfig {
  oneof source {
    string workspace = 1;        // Path to workspace root for uv-based execution
  }

  repeated string pip_packages = 2;  // Additional pip packages to install
  map<string, string> env_vars = 3;  // Environment variables to set
  repeated string extras = 4;         // Extra dependency groups for uv (e.g., ["tpu", "eval"])
}

// ============================================================================
// ENTRYPOINT
// ============================================================================

// Job entrypoint - either a cloudpickled callable or a command line.
// Exactly one must be set.
message Entrypoint {
  oneof kind {
    bytes callable = 1;           // cloudpickle.dumps((fn, args, kwargs))
    CommandEntrypoint command = 2; // Command-line execution
  }
}

// Command-line entrypoint for script execution.
message CommandEntrypoint {
  repeated string argv = 1;  // e.g., ["python", "train.py", "--epochs", "10"]
}

// ============================================================================
// WORKER ATTRIBUTES
// ============================================================================

// Typed attribute value for worker attributes and constraint matching.
// Workers report attributes (e.g., tpu-name, tpu-worker-id) at registration.
// Jobs can filter workers using constraints on these attributes.
message AttributeValue {
  oneof value {
    string string_value = 1;
    int64 int_value = 2;
    double float_value = 3;
  }
}

// Constraint operators for filtering workers by attributes.
enum ConstraintOp {
  CONSTRAINT_OP_EQ = 0;         // Attribute equals value
  CONSTRAINT_OP_NE = 1;         // Attribute not equals value
  CONSTRAINT_OP_EXISTS = 2;     // Attribute exists (value ignored)
  CONSTRAINT_OP_NOT_EXISTS = 3; // Attribute does not exist (value ignored)
  CONSTRAINT_OP_GT = 4;         // Attribute greater than value (numeric)
  CONSTRAINT_OP_GE = 5;         // Attribute greater than or equal to value (numeric)
  CONSTRAINT_OP_LT = 6;         // Attribute less than value (numeric)
  CONSTRAINT_OP_LE = 7;         // Attribute less than or equal to value (numeric)
}

// Constraint for filtering workers by attribute.
// Used in LaunchJobRequest to specify which workers can run a job.
message Constraint {
  string key = 1;           // Attribute key to match (e.g., "tpu-name")
  ConstraintOp op = 2;      // Comparison operator
  AttributeValue value = 3; // Value to compare against (ignored for EXISTS/NOT_EXISTS)
}

// Coscheduling configuration for multi-host jobs.
// When set, all tasks in the job must be scheduled atomically onto workers
// that share the same value for the specified group_by attribute.
message CoschedulingConfig {
  string group_by = 1;  // Attribute key to group workers by (e.g., "tpu-name")
}

// ============================================================================
// WORKER METADATA
// ============================================================================

// Typed metadata about a worker's environment, collected at registration.
message WorkerMetadata {
  // Basic compute resources
  string hostname = 1;
  string ip_address = 2;
  int32 cpu_count = 3;
  int64 memory_bytes = 4;
  int64 disk_bytes = 5;
  DeviceConfig device = 6;

  // TPU environment (from TPU_* env vars)
  string tpu_name = 10;                    // TPU_NAME
  string tpu_worker_hostnames = 11;        // TPU_WORKER_HOSTNAMES
  string tpu_worker_id = 12;               // TPU_WORKER_ID
  string tpu_chips_per_host_bounds = 13;   // TPU_CHIPS_PER_HOST_BOUNDS

  // GPU info (from nvidia-smi)
  int32 gpu_count = 20;
  string gpu_name = 21;
  int32 gpu_memory_mb = 22;

  // GCE instance metadata
  string gce_instance_name = 30;
  string gce_zone = 31;

  // Worker attributes for constraint-based scheduling.
  // Standard attributes include:
  //   tpu-name: TPU slice name (string)
  //   tpu-worker-id: Worker ID within slice (int)
  //   tpu-topology: TPU topology variant, e.g. "v5litepod-16" (string)
  //   tpu-vm-count: Number of VMs in the TPU slice (int)
  // Additional attributes can be set via IRIS_WORKER_ATTRIBUTES env var
  // using format: key1=value1,key2=value2 (e.g., taint:maintenance=true,pool=large-jobs)
  map<string, AttributeValue> attributes = 40;

  // VM address from IRIS_VM_ADDRESS env var, used for autoscaler VM tracking.
  // For cloud VMs, this is the VM's IP address injected by ManagedVm.
  // For local workers, this may be empty or a local identifier.
  string vm_address = 41;
}

// ============================================================================
// CONTROLLER SERVICE MESSAGES
// ============================================================================

message Controller {
  // --- Job Lifecycle ---
  message LaunchJobRequest {
    string name = 1;
    Entrypoint entrypoint = 2;              // Job entrypoint (callable or command)
    ResourceSpecProto resources = 3;        // Full resource specification
    EnvironmentConfig environment = 4;  // Environment configuration

    // Bundle information - either provide gcs_path OR blob (not both)
    string bundle_gcs_path = 5;        // gs://bucket/path/bundle.zip
    string bundle_hash = 6;            // SHA256 hash for caching
    bytes bundle_blob = 7;             // Direct bundle upload (controller writes to bundle_dir)

    // Scheduling timeout - job fails with UNSCHEDULABLE if not scheduled within this time
    // 0 means no timeout (wait forever)
    int32 scheduling_timeout_seconds = 8;

    // Named ports to allocate (e.g., ["http", "grpc", "actor"])
    // Worker allocates ports and injects FLUSTER_PORT_<NAME> env vars into the container
    repeated string ports = 9;

    // Parent job ID for hierarchical job tracking (empty string if root job)
    // Child job IDs are formed as "{parent_job_id}/{name}"
    string parent_job_id = 10;

    // Job-level failure tolerance
    // A job fails when this many tasks have exhausted their retries (default 0 = fail on first task failure)
    // Preemptions do not count toward this limit
    int32 max_task_failures = 11;

    // Per-task retry limits
    // When a task fails (non-zero exit code), retry up to this many times before marking permanently failed
    int32 max_retries_failure = 12;  // Default: 0 (no retries on task failure)

    // When a task is preempted (worker dies), retry up to this many times
    int32 max_retries_preemption = 13;  // Default: 100 (generous preemption tolerance)

    // Constraints for filtering workers by attribute.
    // All constraints must match for a worker to be eligible (AND semantics).
    repeated Constraint constraints = 14;

    // Coscheduling configuration for multi-host jobs (e.g., multi-host TPU).
    // When set, all tasks are scheduled atomically to workers sharing the same
    // group_by attribute value. If not enough workers are available in any group,
    // the job stays pending.
    CoschedulingConfig coscheduling = 15;
  }

  message LaunchJobResponse {
    string job_id = 1;
  }

  message GetJobStatusRequest {
    string job_id = 1;
    bool include_result = 2;  // If true, include serialized_result in response
  }

  message GetJobStatusResponse {
    JobStatus job = 1;
  }

  message TerminateJobRequest {
    string job_id = 1;
  }

  message ListJobsRequest {}

  message ListJobsResponse {
    repeated JobStatus jobs = 1;
  }

  // --- Task Operations ---
  message GetTaskStatusRequest {
    string job_id = 1;
    int32 task_index = 2;
  }

  message GetTaskStatusResponse {
    TaskStatus task = 1;
  }

  message ListTasksRequest {
    string job_id = 1;
  }

  message ListTasksResponse {
    repeated TaskStatus tasks = 1;
  }

  // --- Worker Management ---
  message WorkerInfo {
    string worker_id = 1;
    string address = 2;              // host:port for WorkerService
    WorkerMetadata metadata = 3;
    int64 registered_at_ms = 4;
  }

  message RegisterWorkerRequest {
    string worker_id = 1;
    string address = 2;
    WorkerMetadata metadata = 3;
    // Task IDs the worker believes it is running (for controller restart recovery).
    // If the controller doesn't recognize these tasks, it signals should_reset.
    repeated string running_task_ids = 4;
  }

  message RegisterWorkerResponse {
    bool accepted = 1;
    string controller_address = 2;   // For callbacks
    // If true, worker should reset: kill all containers and re-register with empty task list.
    // Set when worker claims tasks the controller doesn't know about (stale state).
    bool should_reset = 3;
  }

  message WorkerHealthStatus {
    string worker_id = 1;
    bool healthy = 2;
    int32 consecutive_failures = 3;
    int64 last_heartbeat_ms = 4;
    repeated string running_job_ids = 5;
    string address = 6;                    // Worker RPC address (host:port)
    WorkerMetadata metadata = 7;           // Full worker metadata
  }

  message ListWorkersRequest {}

  message ListWorkersResponse {
    repeated WorkerHealthStatus workers = 1;
  }

  // --- Task State Reporting (worker -> controller) ---
  message ReportTaskStateRequest {
    string worker_id = 1;
    string task_id = 2;             // Full task ID
    string job_id = 3;              // Parent job ID (for job-level state aggregation)
    int32 task_index = 4;
    TaskState state = 5;
    int32 exit_code = 6;
    string error = 7;
    int64 finished_at_ms = 8;
    int32 attempt_id = 9;
  }

  message ReportTaskStateResponse {}

  // --- Endpoint Registry ---
  // Endpoints are registered with prefixed names: "{root_job_id}/{actor_name}"
  message Endpoint {
    string endpoint_id = 1;
    string name = 2;                 // Full prefixed name: "abc123/my-actor"
    string address = 3;              // host:port
    string job_id = 4;
    map<string, string> metadata = 5;
  }

  message RegisterEndpointRequest {
    string name = 1;                 // Full prefixed name: "abc123/my-actor"
    string address = 2;
    string job_id = 3;
    map<string, string> metadata = 4;
  }

  message RegisterEndpointResponse {
    string endpoint_id = 1;
  }

  message UnregisterEndpointRequest {
    string endpoint_id = 1;
  }

  message LookupEndpointRequest {
    string name = 1;                 // Full prefixed name: "abc123/my-actor"
  }

  message LookupEndpointResponse {
    Endpoint endpoint = 1;
  }

  message ListEndpointsRequest {
    string prefix = 1;               // Prefix to match: "abc123/" or "abc123/my-actor"
  }

  message ListEndpointsResponse {
    repeated Endpoint endpoints = 1;
  }

  // --- Autoscaler ---
  message GetAutoscalerStatusRequest {}

  message GetAutoscalerStatusResponse {
    iris.vm.AutoscalerStatus status = 1;
  }

  // --- VM Logs ---
  message GetVmLogsRequest {
    string vm_id = 1;
    int32 tail = 2;  // 0 = all lines
  }

  message GetVmLogsResponse {
    string logs = 1;
    string vm_id = 2;
    iris.vm.VmState state = 3;
  }

  // --- Transactions / Actions Log ---
  message TransactionAction {
    int64 timestamp_ms = 1;
    string action = 2;
    string entity_id = 3;
    string details = 4;
  }

  message GetTransactionsRequest {
    int32 limit = 1;  // 0 = default (50)
  }

  message GetTransactionsResponse {
    repeated TransactionAction actions = 1;
  }
}

// ============================================================================
// WORKER SERVICE MESSAGES
// ============================================================================

message Worker {
  message RunTaskRequest {
    string job_id = 1;              // Parent job ID
    string task_id = 2;             // Full task ID: "{job_id}/task-{index}"
    int32 task_index = 3;           // 0-indexed task number
    int32 num_tasks = 4;            // Total tasks in job (for IRIS_NUM_TASKS)

    Entrypoint entrypoint = 5;      // Job entrypoint (callable or command)
    EnvironmentConfig environment = 6;
    string bundle_gcs_path = 7;
    ResourceSpecProto resources = 8;
    int32 timeout_seconds = 9;
    repeated string ports = 10;
    int32 attempt_id = 11;
  }

  message RunTaskResponse {
    string task_id = 1;
    TaskState state = 2;
  }

  message GetTaskStatusRequest {
    string task_id = 1;
    bool include_result = 2;
  }

  message ListTasksRequest {}

  message ListTasksResponse {
    repeated TaskStatus tasks = 1;
  }

  message LogEntry {
    int64 timestamp_ms = 1;
    string source = 2;  // "stdout", "stderr", or "build"
    string data = 3;    // Log line content
  }

  message FetchLogsFilter {
    string regex = 1;
    int64 start_line = 2;
    int64 start_ms = 3;
    int64 end_ms = 4;
    int64 max_lines = 5;
  }

  message FetchTaskLogsRequest {
    string task_id = 1;
    FetchLogsFilter filter = 2;
  }

  message FetchTaskLogsResponse {
    repeated LogEntry logs = 1;
  }

  message KillTaskRequest {
    string task_id = 1;
    int32 term_timeout_ms = 2;      // Time to wait for graceful termination before SIGKILL
  }

  message HealthResponse {
    bool healthy = 1;
    int64 uptime_ms = 2;
    int32 running_tasks = 3;        // Renamed from running_jobs
  }
}

// ============================================================================
// SERVICES
// ============================================================================

service ControllerService {
  // Job lifecycle
  rpc LaunchJob(Controller.LaunchJobRequest) returns (Controller.LaunchJobResponse);
  rpc GetJobStatus(Controller.GetJobStatusRequest) returns (Controller.GetJobStatusResponse);
  rpc TerminateJob(Controller.TerminateJobRequest) returns (Empty);
  rpc ListJobs(Controller.ListJobsRequest) returns (Controller.ListJobsResponse);

  // Task operations
  rpc GetTaskStatus(Controller.GetTaskStatusRequest) returns (Controller.GetTaskStatusResponse);
  rpc ListTasks(Controller.ListTasksRequest) returns (Controller.ListTasksResponse);

  // Worker management (workers send heartbeats to controller)
  rpc RegisterWorker(Controller.RegisterWorkerRequest) returns (Controller.RegisterWorkerResponse);
  rpc ListWorkers(Controller.ListWorkersRequest) returns (Controller.ListWorkersResponse);
  rpc ReportTaskState(Controller.ReportTaskStateRequest) returns (Controller.ReportTaskStateResponse);

  // Endpoint registry (generic service discovery)
  rpc RegisterEndpoint(Controller.RegisterEndpointRequest) returns (Controller.RegisterEndpointResponse);
  rpc UnregisterEndpoint(Controller.UnregisterEndpointRequest) returns (Empty);
  rpc LookupEndpoint(Controller.LookupEndpointRequest) returns (Controller.LookupEndpointResponse);
  rpc ListEndpoints(Controller.ListEndpointsRequest) returns (Controller.ListEndpointsResponse);

  // Autoscaler
  rpc GetAutoscalerStatus(Controller.GetAutoscalerStatusRequest) returns (Controller.GetAutoscalerStatusResponse);

  // VM Logs
  rpc GetVmLogs(Controller.GetVmLogsRequest) returns (Controller.GetVmLogsResponse);

  // Transactions / Actions Log
  rpc GetTransactions(Controller.GetTransactionsRequest) returns (Controller.GetTransactionsResponse);
}

service WorkerService {
  rpc RunTask(Worker.RunTaskRequest) returns (Worker.RunTaskResponse);
  rpc GetTaskStatus(Worker.GetTaskStatusRequest) returns (TaskStatus);
  rpc ListTasks(Worker.ListTasksRequest) returns (Worker.ListTasksResponse);
  rpc FetchTaskLogs(Worker.FetchTaskLogsRequest) returns (Worker.FetchTaskLogsResponse);
  rpc KillTask(Worker.KillTaskRequest) returns (Empty);
  rpc HealthCheck(Empty) returns (Worker.HealthResponse);
}
