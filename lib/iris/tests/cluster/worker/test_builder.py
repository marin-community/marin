# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import subprocess

import pytest
from iris.cluster.worker.builder import ImageCache


@pytest.fixture
def test_bundle(tmp_path):
    """Create a test bundle with pyproject.toml and uv.lock."""
    bundle_dir = tmp_path / "test_bundle"
    bundle_dir.mkdir()

    # Create minimal pyproject.toml
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock file
    # This is a minimal lock file - in real usage it would be generated by uv
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-package"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


@pytest.fixture
def test_bundle_with_deps(tmp_path):
    """Create a test bundle with actual dependencies for real uv testing."""
    bundle_dir = tmp_path / "test_bundle_deps"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_package"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text("# Test package\n")

    # Create pyproject.toml with a simple dependency
    pyproject = """[project]
name = "test-package"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "httpx>=0.28.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_package"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Run uv lock to generate real lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    return bundle_dir


# ImageCache Tests


@pytest.fixture
def docker_bundle(tmp_path):
    """Create a minimal test bundle for Docker builds."""
    bundle_dir = tmp_path / "docker_bundle"
    bundle_dir.mkdir()

    # Create package directory structure
    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')
    (src_dir / "main.py").write_text(
        'def main():\n    print("Hello from Docker!")\n\nif __name__ == "__main__":\n    main()\n'
    )

    # Create pyproject.toml
    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Create uv.lock
    uv_lock = """version = 1
requires-python = ">=3.11"

[[package]]
name = "test-app"
version = "0.1.0"
source = { editable = "." }
"""
    (bundle_dir / "uv.lock").write_text(uv_lock)

    return bundle_dir


def check_docker_available():
    """Check if Docker is available and running."""
    try:
        result = subprocess.run(
            ["docker", "info"],
            check=True,
            capture_output=True,
            timeout=5,
        )
        return result.returncode == 0
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        return False


@pytest.mark.slow
def test_image_cache_initialization(tmp_path):
    """Test ImageCache initialization creates cache directory."""
    cache_dir = tmp_path / "cache"
    ImageCache(cache_dir, registry="localhost:5000", max_images=10)

    assert (cache_dir / "images").exists()


@pytest.mark.slow
def test_image_caching(tmp_path, docker_bundle):
    """Test that subsequent builds to confirm cache usage."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "cache-test-456"
    base_image = "python:3.11-slim"

    # First build - not from cache
    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
    )

    assert result1.from_cache is False
    assert result1.build_time_ms > 0

    # Second build - should be from cache
    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
    )

    assert result2.from_cache is True
    assert result2.build_time_ms == 0
    assert result2.image_tag == result1.image_tag

    # Cleanup
    subprocess.run(["docker", "rmi", result1.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_uv_change_triggers_rebuild(tmp_path, docker_bundle):
    """Test that changing uv lock files triggers a rebuild."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    job_id = "rebuild-test-789"
    base_image = "python:3.11-slim"

    result1 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
    )

    assert result1.from_cache is False

    pyproject_path = docker_bundle / "pyproject.toml"
    pyproject_text = pyproject_path.read_text()
    pyproject_text = pyproject_text.replace('name = "test-app"', 'name = "test-app"\ndescription = "BLAH"')
    pyproject_path.write_text(pyproject_text)

    result2 = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
    )

    assert result2.from_cache is False
    assert result2.image_tag != result1.image_tag

    assert builder._docker.exists(result1.image_tag)
    assert builder._docker.exists(result2.image_tag)

    # Cleanup
    subprocess.run(["docker", "rmi", result1.image_tag], stdout=subprocess.DEVNULL, check=False)
    subprocess.run(["docker", "rmi", result2.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_buildkit_cache_mounts(tmp_path, docker_bundle):
    """Test that BuildKit cache mounts are used for UV cache."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Verify DOCKER_BUILDKIT is set in environment during build
    job_id = "buildkit-test-abc"
    base_image = "python:3.11-slim"

    # Build image - BuildKit should be enabled
    result = builder.build(
        bundle_path=docker_bundle,
        base_image=base_image,
        extras=[],
        job_id=job_id,
    )

    # Verify image was built (BuildKit enabled by default in _docker_build)
    assert result.from_cache is False
    exists = builder._docker.exists(result.image_tag)
    assert exists is True

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_image_build_with_extras(tmp_path):
    """Test building image with extras."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    # Create bundle with extras
    bundle_dir = tmp_path / "extras_bundle"
    bundle_dir.mkdir()

    src_dir = bundle_dir / "src" / "test_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""Test app."""\n')

    pyproject = """[project]
name = "test-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[project.optional-dependencies]
dev = []
test = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/test_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(pyproject)

    # Generate proper lock file
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("uv not available or failed to create lock file")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Build with extras
    result = builder.build(
        bundle_path=bundle_dir,
        base_image="python:3.11-slim",
        extras=["dev", "test"],
        job_id="extras-test",
    )

    assert result.from_cache is False

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_image_build_with_workspace_and_path_deps(tmp_path):
    """Test building image with mixed workspace members and path dependencies."""
    if not check_docker_available():
        pytest.skip("Docker not available")

    bundle_dir = tmp_path / "workspace_bundle"
    bundle_dir.mkdir()

    # Create root package directory
    src_dir = bundle_dir / "src" / "my_app"
    src_dir.mkdir(parents=True)
    (src_dir / "__init__.py").write_text('"""My app."""\n')

    # Root pyproject.toml with workspace member and path dependency
    root_pyproject = """[project]
name = "my-app"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "core",
    "api",
]

[tool.uv.workspace]
members = ["packages/*"]

[tool.uv.sources]
core = { workspace = true }
api = { path = "lib/api", editable = true }

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/my_app"]
"""
    (bundle_dir / "pyproject.toml").write_text(root_pyproject)

    # Create packages directory for workspace members
    packages_dir = bundle_dir / "packages"
    packages_dir.mkdir()

    # Core package - workspace member
    core_dir = packages_dir / "core"
    (core_dir / "src" / "core").mkdir(parents=True)
    (core_dir / "src" / "core" / "__init__.py").write_text('"""Core package."""\n')

    core_pyproject = """[project]
name = "core"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/core"]
"""
    (core_dir / "pyproject.toml").write_text(core_pyproject)

    # Create lib directory for path dependencies
    lib_dir = bundle_dir / "lib"
    lib_dir.mkdir()

    # API package - path dependency
    api_dir = lib_dir / "api"
    (api_dir / "src" / "api").mkdir(parents=True)
    (api_dir / "src" / "api" / "__init__.py").write_text('"""API package."""\n')

    api_pyproject = """[project]
name = "api"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "core",
]

[tool.uv.sources]
core = { path = "../../packages/core", editable = true }

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/api"]
"""
    (api_dir / "pyproject.toml").write_text(api_pyproject)

    # Generate lock file with uv
    try:
        subprocess.run(
            ["uv", "lock"],
            cwd=bundle_dir,
            check=True,
            capture_output=True,
        )
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        pytest.skip(f"uv not available or failed to create lock file: {e}")

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry="localhost:5000")

    # Build image
    result = builder.build(
        bundle_path=bundle_dir,
        base_image="python:3.11-slim",
        extras=[],
        job_id="workspace-path-deps-test",
    )

    assert result.from_cache is False
    assert result.build_time_ms > 0

    # Verify image exists
    assert builder._docker.exists(result.image_tag)

    # Cleanup
    subprocess.run(["docker", "rmi", result.image_tag], stdout=subprocess.DEVNULL, check=False)


@pytest.mark.slow
def test_lru_eviction_of_images(tmp_path, docker_bundle):
    """Test LRU eviction removes old images when over limit."""
    import uuid

    if not check_docker_available():
        pytest.skip("Docker not available")

    # Use a unique registry prefix to isolate this test's images from other runs.
    # The eviction pattern matches {registry}/iris-job-*, so unique registry = isolation.
    test_id = uuid.uuid4().hex[:8]
    test_registry = f"lru-test-{test_id}"

    cache_dir = tmp_path / "cache"
    builder = ImageCache(cache_dir, registry=test_registry, max_images=2)

    base_image = "python:3.11-slim"
    images_built = []

    # Build 3 images to trigger eviction.
    # Eviction sorts by (created_at, tag). When timestamps are identical
    # (common with shared layers), tag is the tiebreaker: job-0 < job-1 < job-2
    for i in range(3):
        result = builder.build(
            bundle_path=docker_bundle,
            base_image=base_image,
            extras=[],
            job_id=f"job-{i}",
        )
        images_built.append(result.image_tag)

    # After building 3 images with max_images=2, oldest should be evicted
    # Note: _evict_old_images is called after each build, but only when count > max_images

    # The oldest image (image 0) should have been evicted
    exists_0 = builder._docker.exists(images_built[0])
    assert exists_0 is False, "Oldest image should have been evicted"

    # The newest images should exist
    exists_1 = builder._docker.exists(images_built[1])
    exists_2 = builder._docker.exists(images_built[2])
    assert exists_1 is True, "Second image should exist"
    assert exists_2 is True, "Newest image should exist"

    # Cleanup remaining images
    for tag in images_built:
        try:
            subprocess.run(["docker", "rmi", tag], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=False)
        except Exception:
            pass  # Image may already be evicted
