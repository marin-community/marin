# Copyright 2025 The Marin Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Inference worker for RL/post-training rollout generation.

This worker loads model checkpoints, generates rollouts from a single environment,
and writes the rollout data to files for training workers to consume.
"""

import dataclasses
import logging
import os
import socket
import threading
import time
from dataclasses import dataclass
from typing import Any

import equinox as eqx
import haliax as hax
import jax
import jax.random as jrandom
import levanter
from jax.experimental import multihost_utils
from levanter.inference.openai import InferenceServer, InferenceServerConfig
from levanter.models.lm_model import LmConfig
from levanter.trainer import TrainerConfig
from levanter.utils.jax_utils import barrier_sync
from transformers import PreTrainedTokenizer

from marin.rl.curriculum import CurriculumConfig, get_or_create_curriculum_actor
from marin.rl.environments import MarinEnv
from marin.rl.environments.base import load_environment_from_spec
from marin.rl.inference_ctx import InferenceContext
from marin.rl.model_utils import load_model_from_checkpoint

from .rollout_storage import RolloutStorageConfig, RolloutWriter
from .types import (
    RolloutBatch,
    RolloutGroup,
    RolloutMetadata,
    RolloutStats,
)
from .weight_transfer import WeightTransferClient, WeightTransferConfig, create_weight_transfer_client

logger = logging.getLogger(__name__)

MAX_INFERENCE_RETRIES = 10


@dataclass
class RolloutWorkerConfig:
    """Configuration for RolloutWorker."""

    inference_server_config: InferenceServerConfig
    trainer: TrainerConfig
    model: LmConfig
    curriculum_config: CurriculumConfig
    rollout_storage: RolloutStorageConfig
    weight_transfer: WeightTransferConfig
    tokenizer: PreTrainedTokenizer
    run_id: str

    seed: int = 0
    """Random seed to use for sampling."""

    max_rollouts: int | None = None
    """Maximum number of rollouts to generate before stopping. Defaults to running forever."""

    initial_checkpoint: str | None = None
    """Initial checkpoint for the reference model (auto-detects HF repo vs local path)."""

    log_freq: int = 10


def find_open_port() -> int:
    """Find an open port on localhost."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("", 0))
        return s.getsockname()[1]


@dataclass
class RolloutBatchStats:
    total_count: int
    success_count: int
    rollout_stats: list[RolloutStats]
    avg_reward: float


def _compute_batch_stats(batch: RolloutBatch, lesson_id: str):
    rollout_stats_list = []
    total_count = 0
    success_count = 0
    reward_sum = 0.0

    for group in batch.groups:
        for rollout in group.rollouts:
            rollout_stats_list.append(
                RolloutStats(
                    lesson_id=lesson_id,
                    episode_reward=rollout.episode_reward,
                    env_example_id=rollout.env_example_id,
                )
            )

            total_count += 1
            if rollout.episode_reward > 0:
                success_count += 1
            reward_sum += rollout.episode_reward

    return RolloutBatchStats(
        total_count=total_count,
        success_count=success_count,
        rollout_stats=rollout_stats_list,
        avg_reward=(reward_sum / total_count) if total_count > 0 else 0.0,
    )


class RolloutWorker:
    """Asynchronous inference & rollout worker for RL training.

    Inference workers periodically load model checkpoints generated by the training job,
    and continously generate rollouts from a single environment. Rollouts are communicated to the
    training job via a rollout queue.
    """

    _inference_thread: threading.Thread
    _inference_server: InferenceServer
    _policy_model: Any
    _transfer_client: WeightTransferClient
    _rollout_writer: RolloutWriter
    _tokenizer: PreTrainedTokenizer
    _environments: dict[str, MarinEnv]

    def __init__(self, config: RolloutWorkerConfig):
        config.trainer.id = f"{config.run_id}-rollout"
        levanter.initialize(config.trainer)

        # Infer model_axis_size from the actual TPU configuration now that JAX is initialized.
        # For inference servers, we shard across all local devices on a single host.
        config.inference_server_config = dataclasses.replace(
            config.inference_server_config,
            trainer=dataclasses.replace(
                config.inference_server_config.trainer,
                model_axis_size=jax.local_device_count(),
            ),
        )

        self.tracker = levanter.current_tracker()
        self.config = config
        self._running = True
        self._shutdown_complete = threading.Event()
        self._shutdown_condition = threading.Condition()
        self._current_weight_step: int = 0

        self._tokenizer = config.tokenizer

        logger.info("Starting weight transfer client with config %s", self.config.weight_transfer)
        self._transfer_client = create_weight_transfer_client(
            config.weight_transfer,
            mesh=self.config.trainer.device_mesh,
            axis_mapping=self.config.trainer.compute_axis_mapping,
        )

        self._rollout_writer = config.rollout_storage.create_writer()
        self._build_models()
        with self.config.trainer.use_device_mesh(), hax.axis_mapping(self.config.trainer.compute_axis_mapping):
            self._inference_server = InferenceServer.create(
                config.inference_server_config,
                model=self._policy_model,
                tokenizer=self._tokenizer,
            )
        self._inference_thread = threading.Thread(target=lambda: self._inference_server.serve(), daemon=True)
        self._inference_thread.start()

        # TODO(power) -- replace this with a wait_until_ready() on the levanter inference server
        time.sleep(1.0)

        self._environments = {}

        # Create curriculum actor (no checkpoint path for rollout workers)
        self._curriculum_actor = get_or_create_curriculum_actor(self.config.curriculum_config)

    def _load_environment(self, lesson_id: str) -> MarinEnv:
        """Load environment from lesson ID."""
        if lesson_id in self._environments:
            return self._environments[lesson_id]

        lesson_config = self.config.curriculum_config.lessons[lesson_id]
        env = load_environment_from_spec(lesson_config.env_config)
        self._environments[lesson_id] = env
        return env

    def _sample_batch(
        self, lesson_id: str, n_examples: int, n_generations: int, mode: str, rng
    ) -> tuple[RolloutBatch | None, dict | None]:
        """Sample a batch of rollouts from the environment for the given lesson ID."""
        env = self._load_environment(lesson_id)
        lesson_config = self.config.curriculum_config.lessons[lesson_id]

        # Get sampling params from lesson config
        temperature = lesson_config.sampling_params.temperature
        stop_tokens = lesson_config.sampling_params.stop_tokens
        max_tokens = lesson_config.sampling_params.max_tokens

        policy_ctx = InferenceContext(
            tokenizer=self._tokenizer,
            inference_server=self._inference_server,
            max_tokens=max_tokens,
            stop_tokens=stop_tokens,
        )

        with (
            self.config.trainer.device_mesh,
            hax.axis_mapping(self.config.trainer.compute_axis_mapping),
        ):
            # Sample examples, generate responses, and create rollouts from selected lesson
            rollout_groups, metrics = env.sample(
                inference_ctx=policy_ctx,
                n_examples=n_examples,
                n_generations=n_generations,
                temperature=temperature,
                prng_key=rng,
                mode=mode,
            )

        if len(rollout_groups) == 0:
            logger.warning("No valid rollouts generated in this batch...")
            return None, None

        logger.info(
            "Generated rollout with %d groups from lesson %s at step %d",
            len(rollout_groups),
            lesson_id,
            self._current_weight_step,
        )

        # Create metadata once for this batch
        batch_metadata = RolloutMetadata(
            worker_id=f"{socket.gethostname()}_{os.getpid()}",
            timestamp=time.time(),
            weight_step=self._current_weight_step,
        )

        # Attach metadata to each rollout in each group
        rollout_groups_with_metadata = []
        for group in rollout_groups:
            rollouts_with_metadata = []
            for rollout in group.rollouts:
                # Create new rollout with metadata attached
                rollout_with_meta = eqx.tree_at(lambda r: r.metadata, rollout, batch_metadata)
                rollouts_with_metadata.append(rollout_with_meta)

            rollout_groups_with_metadata.append(RolloutGroup(rollouts=rollouts_with_metadata))

        rollout_batch = RolloutBatch(
            groups=rollout_groups_with_metadata,
            metadata=batch_metadata,
        )
        return rollout_batch, metrics

    def _build_models(self):
        if self.config.initial_checkpoint is not None:
            logger.info(f"Loading initial policy model from checkpoint: {self.config.initial_checkpoint}")
        else:
            logger.info("Building new policy model from scratch")

        key = jrandom.PRNGKey(self.config.seed)
        vocab_size = self._tokenizer.vocab_size
        Vocab = hax.Axis("vocab", vocab_size)

        initial_model = load_model_from_checkpoint(
            checkpoint=self.config.initial_checkpoint,
            model_config=self.config.model,
            trainer_config=self.config.trainer,
            mesh=self.config.trainer.device_mesh,
            # use the compute axis mapping for inference
            axis_mapping=self.config.trainer.compute_axis_mapping,
            vocab_axis=Vocab,
            tokenizer=self._tokenizer,
            key=key,
        )

        logger.info("Initializing policy model from initial checkpoint")
        self._policy_model = initial_model

    def stop(self):
        """Stop the inference worker loop and server."""
        with self._shutdown_condition:
            self._running = False
            self._transfer_client.cleanup()
            self._shutdown_condition.notify()

        # Wait for the main loop to finish
        self._shutdown_complete.wait()

        # Now shutdown the inference server
        if self._inference_server:
            self._inference_server.shutdown()

    def _sync_weights(self):
        max_wait_time = self.config.weight_transfer.max_weight_transfer_wait_time
        start_time = time.time()

        while True:
            logger.info("Checking for new weights...")
            update = self._transfer_client.receive_weights(self._policy_model)
            if update:
                break

            elapsed = time.time() - start_time
            if elapsed >= max_wait_time:
                logger.info(f"Waited {elapsed:.1f}s for new weights, proceeding with current weights")
                return None

            time.sleep(1.0)

        if update:
            self._current_weight_step = update.weight_id
            logger.info(f"Received new weights from step {update.weight_id}")
            self._policy_model = update.model
            self._inference_server.reload(lambda model: self._policy_model)
            return update.model
        else:
            logger.info("No new weights available")
            return None

    def _log_prompt_example(self, lesson_id: str, batch: RolloutBatch, step: int, eval_type: str = "eval") -> None:
        """Log a single representative sample from an evaluation batch.

        Args:
            lesson_id: ID of the evaluated lesson
            batch: The rollout batch containing samples
            step: Current training step
            mode: Either "eval" or "micro_eval"
        """
        if not batch or not batch.groups:
            return

        # Take first rollout from first group as representative
        sample = batch.groups[0].rollouts[0]

        # Decode tokens to human-readable text
        prompt_text = self._tokenizer.decode(sample.prompt_tokens, skip_special_tokens=True)
        response_text = self._tokenizer.decode(sample.response_tokens, skip_special_tokens=True)

        # Log with structured keys
        prefix = f"inference.{eval_type}/{lesson_id}"
        metrics = {
            f"{prefix}/sample_prompt": prompt_text,
            f"{prefix}/sample_response": response_text,
            f"{prefix}/sample_example_id": sample.env_example_id,
        }
        self.tracker.log(metrics, step=step)
        logger.info(f"Eval sample for lesson {lesson_id} at step {step}: {metrics}")

    def _build_eval_metrics(self, prefix: str, lesson_id: str, batch: RolloutBatch) -> dict[str, Any]:
        metrics = {}
        stats = _compute_batch_stats(batch, lesson_id)
        if stats.total_count == 0:
            return metrics
        success_rate = stats.success_count / stats.total_count
        metrics[f"{prefix}/{lesson_id}/success_rate"] = success_rate
        metrics[f"{prefix}/{lesson_id}/avg_reward"] = stats.avg_reward
        metrics[f"{prefix}/{lesson_id}/total_count"] = stats.total_count
        return metrics

    def _evaluate_lesson(self, lesson_id: str, n_examples: int, eval_type: str, rng, step: int) -> dict:
        """Evaluate a single lesson and log metrics."""
        batch, _ = self._sample_batch(
            lesson_id=lesson_id,
            n_examples=n_examples,
            n_generations=1,
            mode="eval",
            rng=rng,
        )
        stats = _compute_batch_stats(batch, lesson_id)
        self._log_prompt_example(lesson_id, batch, step, eval_type=eval_type)
        metrics = self._build_eval_metrics(prefix=f"inference.{eval_type}", lesson_id=lesson_id, batch=batch)
        self.tracker.log(metrics, step=step)
        logger.info("Eval metrics for lesson %s at step %d: %s", lesson_id, step, metrics)
        # only update curriculum for full evals
        if eval_type == "eval":
            self._curriculum_actor.update_lesson_stats.options(enable_task_events=False).call(
                stats.rollout_stats, mode="eval", current_step=step
            )
        return stats

    def _evaluate_curriculum(self, rng, step: int) -> dict:
        """Evaluate all lessons and update the curriculum actor."""
        lesson_names = list(self.config.curriculum_config.lessons.keys())
        if not lesson_names:
            logger.info("No lessons to evaluate")
            return {}

        logger.info(f"Evaluating {len(lesson_names)} lessons")

        for lesson_id in lesson_names:
            self._evaluate_lesson(
                lesson_id, self.config.curriculum_config.eval_n_examples, eval_type="eval", rng=rng, step=step
            )

        barrier_sync()

    def run(self):
        """Main inference worker loop."""
        logger.info("Starting inference worker...")

        step = 0

        seed = self.config.seed
        rng = jax.random.PRNGKey(seed)
        rng = multihost_utils.broadcast_one_to_all(rng)
        logger.info(f"Starting rollout worker with seed {seed}")

        while self._running:
            self._sync_weights()

            if self.config.max_rollouts is not None and step >= self.config.max_rollouts:
                logger.info(f"Reached max rollouts ({self.config.max_rollouts}), stopping")
                break

            logger.info("Generating rollout batch...")
            rng, seed_key = jax.random.split(rng)
            seed = int(seed_key[0])
            try:
                lesson_id = self._curriculum_actor.sample_lesson.call(seed)
            except Exception as e:
                logger.warning(f"Failed to sample lesson from curriculum: {e}, will try again...")
                time.sleep(10.0)
                continue

            # Micro-eval: feedback on current lesson
            if step > 0 and step % self.config.curriculum_config.micro_eval_frequency == 0:
                rng, micro_eval_rng = jrandom.split(rng)
                self._evaluate_lesson(
                    lesson_id,
                    self.config.curriculum_config.micro_eval_n_examples,
                    eval_type="micro_eval",
                    rng=micro_eval_rng,
                    step=step,
                )

            # Full eval: comprehensive check on all lessons
            if step > 0 and step % self.config.curriculum_config.eval_frequency == 0:
                rng, eval_rng = jrandom.split(rng)
                self._evaluate_curriculum(eval_rng, step)

            logger.info(f"Sampled lesson '{lesson_id}' from curriculum")

            rng, input_rng = jax.random.split(rng)
            lesson_config = self.config.curriculum_config.lessons[lesson_id]

            for attempt in range(MAX_INFERENCE_RETRIES):
                try:
                    rollout_batch, env_metrics = self._sample_batch(
                        lesson_id=lesson_id,
                        n_examples=lesson_config.sampling_params.n_prompts,
                        n_generations=lesson_config.sampling_params.n_generations_per_prompt,
                        mode="train",
                        rng=input_rng,
                    )
                    break
                except Exception as e:
                    logger.warning(
                        f"Failed to sample batch from lesson {lesson_id}: {e}, will try again... \
                            (attempt {attempt + 1}/{MAX_INFERENCE_RETRIES})"
                    )
                    time.sleep(5.0)
                    continue

            if rollout_batch is None:
                continue

            stats = _compute_batch_stats(rollout_batch, lesson_id)
            self._curriculum_actor.update_lesson_stats.options(enable_task_events=False).call(
                stats.rollout_stats, mode="training", current_step=step
            )
            eval_metrics = self._build_eval_metrics(prefix="rollout", lesson_id=lesson_id, batch=rollout_batch)

            step += 1
            self._rollout_writer.write_batch(rollout_batch)

            if self.config.log_freq > 0 and step % self.config.log_freq == 0:
                log_metrics = eval_metrics
                log_metrics.update(self._transfer_client.get_metrics())
                log_metrics.update({f"env.{k}": v for k, v in (env_metrics or {}).items()})
                log_metrics = {"inference." + k: v for k, v in log_metrics.items()}
                logger.info(f"Logging metrics at step {step}... {log_metrics}")
                self.tracker.log(log_metrics, step=step)

        logger.info(f"Inference worker completed after generating {step} rollouts")
        barrier_sync()
        self._shutdown_complete.set()
