import abc
import re
from dataclasses import dataclass
from typing import ClassVar

import ray

from marin.core.runtime import TaskConfig, map_files_in_directory
from marin.generation.dataset import convert_labeled_documents_to_scores


@dataclass
class DatasetOutputProcessorConfig:
    input_path: str
    output_path: str
    processor_type: str
    columns_to_keep: list[str]


class DatasetOutputProcessor:
    """Base class for converting labeled documents into a dataset of parsed scores.

    This processor will take in a path to a directory of labeled documents with a "text" and "generated_text" field
    where "text" is the original text and "generated_text" is the text generated by the model. The processor
    will then convert the labeled documents into a dataset of parsed scores by implementing
    the `extract_score` method.

    Inputs:
        input_path: The path to the input file.
        output_path: The path to the output file.
        score_values: The list of score values (the possible values that the score can take on).
    """

    def __init__(self, input_path: str, output_path: str, columns_to_keep: list[str]):
        self.input_path = input_path
        self.output_path = output_path
        self.columns_to_keep = columns_to_keep

    @abc.abstractmethod
    def extract_score(text: str) -> int:
        raise NotImplementedError("Subclasses must implement this method")

    def convert_dataset(self):
        responses = map_files_in_directory(
            convert_labeled_documents_to_scores.remote,
            self.input_path,
            "**/*.jsonl.gz",
            self.output_path,
            TaskConfig(),
            False,
            self.extract_score,
            self.columns_to_keep,
        )

        aggregated_score_distribution = {}
        for score_distribution in ray.get(responses):
            for score, count in score_distribution.items():
                aggregated_score_distribution[score] = aggregated_score_distribution.get(score, 0) + count

        return aggregated_score_distribution


class MeduDatasetOutputProcessor(DatasetOutputProcessor):
    SCORE_OPTIONS_DICT: ClassVar[dict[str, int]] = {
        "Great": 5,
        "Good": 4,
        "Okay": 3,
        "Poor": 2,
        "Useless": 1,
    }

    def __init__(self, input_path: str, output_path: str, columns_to_keep: list[str]):
        super().__init__(input_path, output_path, columns_to_keep)

    @staticmethod
    def extract_score(text: str) -> int:

        # Match "Final Score: " followed by one of the score options
        match = re.search(r"Final Score:\s*(Great|Good|Okay|Poor|Useless)", text)
        if match:
            score_text = match.group(1)
            return MeduDatasetOutputProcessor.SCORE_OPTIONS_DICT[score_text]

        return -1


class FinalScoreZeroToFiveDatasetOutputProcessor(DatasetOutputProcessor):
    SCORE_OPTIONS_DICT: ClassVar[dict[str, int]] = {str(i): i for i in range(6)}

    def __init__(self, input_path: str, output_path: str, columns_to_keep: list[str]):
        super().__init__(input_path, output_path, columns_to_keep)

    @staticmethod
    def extract_score(text: str) -> int:

        # Match "Final score: " followed by a number from 0 to 5
        match = re.search(r"Final score:\s*([0-5])", text, re.IGNORECASE)
        if match:
            score_text = match.group(1)
            return FinalScoreZeroToFiveDatasetOutputProcessor.SCORE_OPTIONS_DICT[score_text]

        return -1


class AutoDatasetOutputProcessor(DatasetOutputProcessor):
    _PROCESSOR_TYPE_TO_CLS: ClassVar[dict] = {
        "medu": MeduDatasetOutputProcessor,
        "finalscore0-5": FinalScoreZeroToFiveDatasetOutputProcessor,
    }

    @classmethod
    def from_processor_type(cls, input_path, output_path, processor_type, columns_to_keep):
        processor_cls = cls._PROCESSOR_TYPE_TO_CLS[processor_type]
        return processor_cls(input_path, output_path, columns_to_keep)
