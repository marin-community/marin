{
  "base_ref": "main",
  "comments": [
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 65,
      "comment": "should these have comparator functions",
      "diff_context": "+    value: str | int | float"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 110,
      "comment": "this is expensive for frequently updated lists. evaluate a heapq or similar. e.g. imagine scheduling 1000 tasks in a row, this will need to be resorted every time.\n\ndo we need exact index/range index? or just a single index type? - exact index can be replicated by creating a posting list `attribute=value` or something similar?",
      "diff_context": "+    range_index: list[tuple[float, WorkerId]]  # sorted by value descending"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 120,
      "comment": "let's make this part of workcapacity instead of passing it around separately?",
      "diff_context": "+    def update_worker(self, worker_id: WorkerId, attrs: dict[str, AttributeValue]):"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 140,
      "comment": "this should be lazy instead, this approach is bad. instead iterate over the lists, from left to right, yielding as you find matches. the lists support seeking, so you'll maintain a list of iterators and seek until they align. (or something similar, you can do it!)",
      "diff_context": "+    candidates = set(w.worker_id for w in workers)"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 149,
      "comment": "are these not also constraints, just negated?",
      "diff_context": "+    for w in workers:"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 217,
      "comment": "is this a part of scheduler? or not? why doesn't it have a self?\n\nwe don't want to rebuild this list every time.\nwe want to group tasks by co-scheduling group, not job.",
      "diff_context": "+    tasks_by_job: dict[JobId, list[ControllerTask]] = ..."
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 249,
      "comment": "this seems bad, doesn't state.py decide what to do, not some random free-function?",
      "diff_context": "+def handle_coscheduled_task_failure(state: ControllerState, failed_task: ControllerTask):"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 244,
      "comment": "you ahven't documented the deletion/removal of the gang scheduling logic",
      "diff_context": "+### Task Failure \u2192 Group Failure"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 285,
      "comment": "this needs to send the kill message to any workers that successfull scheduled",
      "diff_context": "+            for t, w in dispatched:"
    },
    {
      "file": "lib/iris/docs/coscheduling-tpu.md",
      "line": 301,
      "comment": "just take these as arugments, don't overcomplicate it",
      "diff_context": "+class ControllerComponents:"
    }
  ]
}