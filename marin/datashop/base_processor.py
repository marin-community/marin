import abc
from dataclasses import dataclass
from typing import ClassVar

import ray

from marin.core.runtime import TaskConfig, map_files_in_directory
from marin.generation.dataset import convert_labeled_documents_to_scores


@dataclass
class DatasetOutputProcessorConfig:
    input_path: str
    output_path: str
    processor_type: str


class DatasetOutputProcessor:
    """Base class for converting labeled documents into a dataset of parsed scores.

    This processor will take in a path to a directory of labeled documents with a "text" and "generated_text" field
    where "text" is the original text and "generated_text" is the text generated by the model. The processor
    will then convert the labeled documents into a dataset of parsed scores by implementing
    the `extract_score` method.

    Inputs:
        input_path: The path to the input file.
        output_path: The path to the output file.
        score_values: The list of score values (the possible values that the score can take on).
    """

    _PROCESSOR_TYPE_TO_CLS: ClassVar[dict] = {
        "medu": "MeduDatasetOutputProcessor",
        "final-score0-5": "FinalScoreZeroToFiveDatasetOutputProcessor",
    }

    def __init__(self, input_path: str, output_path: str, score_values: list[int]):
        self.input_path = input_path
        self.output_path = output_path
        self.score_values = score_values
        self.score_distribution = {v: 0 for v in score_values}

    @classmethod
    def from_processor_type(cls, input_path, output_path, processor_type):
        processor_cls = getattr(
            __import__("marin.datashop.dataset_processor"), cls._PROCESSOR_TYPE_TO_CLS[processor_type]
        )
        return processor_cls(input_path, output_path)

    @abc.abstractmethod
    def extract_score(text: str) -> int:
        raise NotImplementedError("Subclasses must implement this method")

    def convert_dataset(self):
        responses = map_files_in_directory(
            convert_labeled_documents_to_scores.remote,
            self.input_path,
            "**/*.jsonl.gz",
            self.output_path,
            TaskConfig(),
            False,
            self.score_values,
            self.extract_score,
        )

        for score_distribution in ray.get(responses):
            for score, count in score_distribution.items():
                self.score_distribution[score] = self.score_distribution.get(score, 0) + count

        return self.score_distribution
